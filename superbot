#!/bin/bash
# Superbot launcher — assembles live context and starts claude
# Supports self-restart: touch ~/.superbot/.restart from within a session
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1

DIR="$HOME/.superbot"
TEAM_DIR="$HOME/.claude/teams/superbot"
PLUGIN_ROOT="$(cd "$(dirname "$0")" && pwd)"
RESTART_FLAG="$DIR/.restart"
LAUNCHER_PID=$$

# --- Subcommands (handled before launching claude) ---
case "${1:-}" in
  update)
    echo "Updating superbot..."
    echo ""

    # 1. Pull latest code (prompts, scripts, UI source, templates)
    cd "$PLUGIN_ROOT"
    BEFORE=$(git rev-parse HEAD 2>/dev/null)
    git pull --ff-only 2>&1
    AFTER=$(git rev-parse HEAD 2>/dev/null)
    if [[ "$BEFORE" == "$AFTER" ]]; then
      echo "Code: already up to date."
    else
      echo "Code: updated $(git log --oneline "$BEFORE..$AFTER" | wc -l | tr -d ' ') commits:"
      git log --oneline "$BEFORE..$AFTER"
    fi
    echo ""

    # 2. Force-update built-in skills (superbot's own, always overwrite)
    SKILLS_DIR="$HOME/.claude/skills"
    mkdir -p "$SKILLS_DIR"
    for skill_dir in "$PLUGIN_ROOT"/skills/*/; do
      [[ -d "$skill_dir" ]] || continue
      skill_name="$(basename "$skill_dir")"
      rm -rf "$SKILLS_DIR/$skill_name"
      cp -r "$skill_dir" "$SKILLS_DIR/$skill_name"
      echo "Updated skill: $skill_name"
    done

    # 3. Re-install superpowers skills (force update)
    SUPERPOWERS_SKILLS=(
      brainstorming dispatching-parallel-agents executing-plans
      finishing-a-development-branch receiving-code-review requesting-code-review
      subagent-driven-development systematic-debugging test-driven-development
      using-git-worktrees using-superpowers verification-before-completion
      writing-plans writing-skills
    )
    echo ""
    echo "Updating superpowers skills..."
    for skill in "${SUPERPOWERS_SKILLS[@]}"; do
      npx skills add obra/superpowers-marketplace@"$skill" -g -a claude-code -y 2>/dev/null \
        && echo "  Updated $skill" \
        || echo "  Warning: could not update $skill"
    done

    # 4. Ensure general space exists
    if [[ ! -d "$DIR/spaces/general" ]]; then
      bash "$PLUGIN_ROOT/scripts/create-space.sh" general "General" "" "Catch-all space for tasks that don't belong to a specific space"
      echo "Created general space"
    fi

    echo ""
    echo "Update complete. Restart superbot to pick up changes."
    exit 0
    ;;
esac

# Guard: run setup if not initialized
if [[ ! -d "$DIR" ]]; then
  echo "Superbot not set up yet. Running setup..."
  "$PLUGIN_ROOT/scripts/setup.sh"
fi

# --- Context assembly function (re-runs on each restart) ---
assemble_context() {
  local CWD="$(pwd)"
  local IS_GIT="false"
  if git -C "$CWD" rev-parse --is-inside-work-tree &>/dev/null; then
    IS_GIT="true"
  fi
  local CURRENT_DATE="$(date '+%Y-%m-%d')"
  local CURRENT_TIME="$(date '+%A %B %-d, %-I:%M %p')"
  local OS_VERSION="$(uname -s) $(uname -r)"
  local PLATFORM="$(uname -s | tr '[:upper:]' '[:lower:]')"

  CONTEXT=""

  # Environment
  CONTEXT+="# Environment"$'\n'
  CONTEXT+="- Primary working directory: $CWD"$'\n'
  CONTEXT+="- Is a git repository: $IS_GIT"$'\n'
  CONTEXT+="- Platform: $PLATFORM"$'\n'
  CONTEXT+="- OS Version: $OS_VERSION"$'\n'
  CONTEXT+="- Current date and time: $CURRENT_TIME ($CURRENT_DATE)"$'\n'
  CONTEXT+="- Knowledge cutoff: May 2025"$'\n'
  CONTEXT+="- Model family: Claude 4.5/4.6 (Opus 4.6: claude-opus-4-6, Sonnet 4.5: claude-sonnet-4-5-20250929, Haiku 4.5: claude-haiku-4-5-20251001)"$'\n'
  CONTEXT+=$'\n---\n\n'

  # Claude base system prompt
  if [[ -f "$PLUGIN_ROOT/templates/CLAUDE_SYSTEM_PROMPT.md" ]]; then
    CONTEXT+="$(cat "$PLUGIN_ROOT/templates/CLAUDE_SYSTEM_PROMPT.md")"
    CONTEXT+=$'\n\n---\n\n'
  fi

  # Superbot system instructions
  if [[ -f "$PLUGIN_ROOT/templates/SYSTEM.md" ]]; then
    CONTEXT+="$(cat "$PLUGIN_ROOT/templates/SYSTEM.md")"
    CONTEXT+=$'\n\n---\n\n'
  fi

  # Identity, User, Memory, Heartbeat
  for file in IDENTITY USER MEMORY HEARTBEAT; do
    if [[ -f "$DIR/$file.md" ]]; then
      CONTEXT+="## $file"$'\n'
      CONTEXT+="$(cat "$DIR/$file.md")"
      CONTEXT+=$'\n\n---\n\n'
    fi
  done

  # Today's daily notes
  local TODAY="$DIR/daily/$(date '+%Y-%m-%d').md"
  if [[ -f "$TODAY" ]]; then
    CONTEXT+="## Today's Notes"$'\n'
    CONTEXT+="$(cat "$TODAY")"
    CONTEXT+=$'\n\n---\n\n'
  fi

  # Recent daily notes (today + yesterday)
  local YESTERDAY="$DIR/daily/$(date -v-1d '+%Y-%m-%d' 2>/dev/null || date -d 'yesterday' '+%Y-%m-%d' 2>/dev/null).md"
  if [[ -f "$YESTERDAY" ]]; then
    CONTEXT+="## Yesterday's Notes"$'\n'
    CONTEXT+="$(cat "$YESTERDAY")"
    CONTEXT+=$'\n\n---\n\n'
  fi

  # Spaces dashboard
  if ls "$DIR/spaces"/*/space.json &>/dev/null; then
    CONTEXT+="## Spaces"$'\n'
    for space_json in "$DIR/spaces"/*/space.json; do
      space_name=$(jq -r '.name' "$space_json")
      space_status=$(jq -r '.status' "$space_json")
      space_priority=$(jq -r '.priority // "medium"' "$space_json")
      space_dir=$(dirname "$space_json")
      pending=$(grep -rl '"status":"pending"' "$space_dir/tasks/" 2>/dev/null | wc -l | tr -d ' ')
      in_progress=$(grep -rl '"status":"in_progress"' "$space_dir/tasks/" 2>/dev/null | wc -l | tr -d ' ')
      CONTEXT+="- **$space_name** [$space_status, $space_priority] — ${pending} pending, ${in_progress} in progress"$'\n'
    done
    CONTEXT+=$'\n\n---\n\n'
  fi

  # Active sessions dashboard
  local SESSIONS_FILE="$DIR/sessions.json"
  if [[ -f "$SESSIONS_FILE" ]]; then
    local ACTIVE_COUNT
    ACTIVE_COUNT=$(jq '[.sessions[] | select(.status == "active")] | length' "$SESSIONS_FILE" 2>/dev/null)
    if [[ "$ACTIVE_COUNT" -gt 0 ]]; then
      CONTEXT+="## Active Sessions ($ACTIVE_COUNT)"$'\n'
      CONTEXT+=$(jq -r '.sessions[] | select(.status == "active") | "- **\(.name)** [\(.type)] — \(.slackThread.channel // "no thread")"' "$SESSIONS_FILE" 2>/dev/null)
      CONTEXT+=$'\n\n---\n\n'
    fi
  fi
}

# --- Restart background daemons (Slack bot, heartbeat, scheduler) ---
restart_daemons() {
  local LAUNCH_DIR="$HOME/Library/LaunchAgents"
  for plist in com.claude.superbot-slack com.claude.superbot-heartbeat com.claude.superbot-scheduler; do
    if [[ -f "$LAUNCH_DIR/$plist.plist" ]]; then
      launchctl unload "$LAUNCH_DIR/$plist.plist" 2>/dev/null
      launchctl load "$LAUNCH_DIR/$plist.plist" 2>/dev/null
      echo "  Restarted $plist"
    fi
  done
}

# --- Find the most recent session ID for this workspace ---
find_session_id() {
  # Claude stores sessions as .jsonl files in ~/.claude/projects/<encoded-cwd>/
  local CWD_ENCODED
  CWD_ENCODED=$(pwd | sed 's|/|-|g')
  local SESSION_DIR="$HOME/.claude/projects/$CWD_ENCODED"
  if [[ -d "$SESSION_DIR" ]]; then
    local LATEST
    LATEST=$(ls -t "$SESSION_DIR"/*.jsonl 2>/dev/null | head -1)
    if [[ -n "$LATEST" ]]; then
      basename "$LATEST" .jsonl
    fi
  fi
}

# --- Main loop with restart support ---
rm -f "$RESTART_FLAG"
RESUME_SESSION=""

while true; do
  # Assemble fresh context each iteration
  assemble_context

  # Start watchdog: monitors for restart flag, kills claude when found
  (
    while true; do
      sleep 1
      if [[ -f "$RESTART_FLAG" ]]; then
        # Kill direct children of the launcher (the claude process)
        pkill -INT -P $LAUNCHER_PID 2>/dev/null
        exit 0
      fi
    done
  ) &
  WATCHDOG_PID=$!

  # Build claude args
  CLAUDE_ARGS=(
    --system-prompt "$CONTEXT"
    --dangerously-skip-permissions
    --plugin-dir "$PLUGIN_ROOT"
    --team-name superbot
    --agent-name team-lead
    --agent-id team-lead@superbot
  )

  # Use --resume on restarts, fresh session ID on new starts
  if [[ -n "$RESUME_SESSION" ]]; then
    CLAUDE_ARGS+=(--resume "$RESUME_SESSION")
  else
    # Generate a new session ID and update the team config to match
    LEAD_SESSION=$(uuidgen | tr '[:upper:]' '[:lower:]')
    jq --arg sid "$LEAD_SESSION" '.leadSessionId = $sid' \
      "$TEAM_DIR/config.json" > "$TEAM_DIR/config.json.tmp" \
      && mv "$TEAM_DIR/config.json.tmp" "$TEAM_DIR/config.json"
    CLAUDE_ARGS+=(--session-id "$LEAD_SESSION")
  fi

  # Run claude (foreground, gets full terminal)
  if [[ -n "$RESUME_SESSION" ]]; then
    # Restart: send a kickoff message instead of original CLI args
    claude "${CLAUDE_ARGS[@]}" "Session restarted. Continue where you left off."
  else
    # First run: pass through any user-provided CLI args
    claude "${CLAUDE_ARGS[@]}" "$@"
  fi

  # Claude exited — clean up watchdog
  kill $WATCHDOG_PID 2>/dev/null
  wait $WATCHDOG_PID 2>/dev/null

  # Check if this was a restart request
  if [[ -f "$RESTART_FLAG" ]]; then
    rm -f "$RESTART_FLAG"

    # Grab the session ID before restarting
    RESUME_SESSION=$(find_session_id)

    echo ""
    if [[ -n "$RESUME_SESSION" ]]; then
      echo "Superbot restarting — resuming session $RESUME_SESSION"
    else
      echo "Superbot restarting — fresh session (no session ID found)"
    fi
    restart_daemons
    echo ""
    continue
  fi

  # Normal exit — clear resume state
  RESUME_SESSION=""
  break
done
